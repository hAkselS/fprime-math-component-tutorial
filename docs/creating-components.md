# Creating Components

## Part 1: MathSender

Start by creating and navigating to the directory where the components will live. 

```shell 
# In: MathProject
mkdir Components
cd Components 
```

The MathSender is going to be an active component which will send receive parameters, send parameters, log events, and send telemetry. With this is mind, use the following command to create the MathSender component. 

```shell
# In: Components
fprime-util new --component 
```
This command will prompt you for some inputs. You should specify the follow so that the components matches the short description above. 

```
[INFO] Cookiecutter source: using builtin
component_name [MyComponent]: MathSender 
component_short_description [Example Component for F Prime FSW framework.]: Active component used for sending operations and operrands to the MathReceiver.
Component_namespace[Component]: MathModule
Select component_kind:
1 - active
2 - passive
3 - queued
Choose from 1, 2, 3 [1]: 1
Select enable_commands:
1 - yes
2 - no
Choose from 1, 2 [1]: 1
Select enable_telemetry:
1 - yes
2 - no
Choose from 1, 2 [1]: 1
Select enable_events:
1 - yes
2 - no
Choose from 1, 2 [1]: 1
Select enable_parameters:
1 - yes
2 - no
Choose from 1, 2 [1]: 1
[INFO] Found CMake file at 'MathProject/project.cmake'
Add component Components/MathSender to MathProject/project.cmake at end of file (yes/no)? yes
Generate implementation files (yes/no)? yes
```
Before doing anything to the files you have just generated, try building. 

```shell 
# In: Components
fprime-util build
```

Now that you have created the component, you can implement the component behavior. The first part of implementing component behavior is editting the fpp file. The fpp file will specify what goes into the autogenerated cpp and hpp files. Writing the fpp file will not implement component behavior on its own, but it will generate templates for everything you will need to write in cpp. 

In Components/MathSender, open MathSender.fpp and entirely replace its contents with the following. (Note: this is an old format of fpp files but the content is entirely correct. @TOTO).

```fpp
module MathModule {

  @ Component for sending a math operation
  active component MathSender {

    # ----------------------------------------------------------------------
    # General ports
    # ----------------------------------------------------------------------

    @ Port for sending the operation request
    output port mathOpOut: MathOp

    @ Port for receiving the result
    async input port mathResultIn: MathResult

    # ----------------------------------------------------------------------
    # Special ports
    # ----------------------------------------------------------------------

    @ Command receive port
    command recv port cmdIn

    @ Command registration port
    command reg port cmdRegOut

    @ Command response port
    command resp port cmdResponseOut

    @ Event port
    event port eventOut

    @ Telemetry port
    telemetry port tlmOut

    @ Text event port
    text event port textEventOut

    @ Time get port
    time get port timeGetOut

    # ----------------------------------------------------------------------
    # Commands
    # ----------------------------------------------------------------------

    @ Do a math operation
    async command DO_MATH(
                           val1: F32 @< The first operand
                           op: MathOp @< The operation
                           val2: F32 @< The second operand
                         )

    # ----------------------------------------------------------------------
    # Events
    # ----------------------------------------------------------------------

    @ Math command received
    event COMMAND_RECV(
                        val1: F32 @< The first operand
                        op: MathOp @< The operation
                        val2: F32 @< The second operand
                      ) \
      severity activity low \
      format "Math command received: {f} {} {f}"

    @ Received math result
    event RESULT(
                  result: F32 @< The math result
                ) \
      severity activity high \
      format "Math result is {f}"

    # ----------------------------------------------------------------------
    # Telemetry
    # ----------------------------------------------------------------------

    @ The first value
    telemetry VAL1: F32

    @ The operation
    telemetry OP: MathOp

    @ The second value
    telemetry VAL2: F32

    @ The result
    telemetry RESULT: F32

  }

}
```

More about this component @TODO 

Now you have written the F' code for the component, but the cpp and hpp files do not yet reflect the changes you have made to the fpp file. To get the cpp and hpp to reflect the specs you have set fourth in the fpp, you need to use F' imlpement as done below. 

```shell
# In: Components
fprime-util impl 
```

If you look in Components, you will see that two new files, MathSender.cpp-template and MathSender.hpp-template. The template files are the files we just generated using our fpp model. So as to not burn down any work that had been done in the orginal MathSender.cpp or hpp, whenever F' generates code, its created a new file. In this case, you did not write anything into MathSender.cpp or .hpp. So, you can use a move command to write the new, generated MathSender.cpp and .hpp, over the old MathSender.cpp and .hpp. 

Use the following to write the new MathSender.cpp and .hpp over the old .cpp and .hpp.

```shell 
# In: MathSender
mv MathSender.cpp-template MathSender.cpp
mv MathSender.hpp-template MathSender.hpp
```

Build MathSender to make sure everything worked as expecred.

```shell 
# In: MathSender 
fprime-util build 
```
 
Edit the MathSender.cpp to implement the component behavior. Use a text editor to make the following edits to MathSender.cpp.


Fill in the DO_MATH command handler: You should see a stub handler for the DO_MATH command that looks like this:

```cpp
void MathSender ::
  DO_MATH_cmdHandler(
      const FwOpcodeType opCode,
      const U32 cmdSeq,
      F32 val1,
      MathOp op,
      F32 val2
  )
{
  // TODO
  this->cmdResponse_out(opCode,cmdSeq,Fw::CmdResponse::OK);
}
```

The handler DO_MATH_handler is called when the MathSender component receives a DO_MATH command. This handler overrides the corresponding pure virtual function in the auto-generated base class. Fill in the handler so that it looks like this:

```cpp
void MathSender ::
  DO_MATH_cmdHandler(
      const FwOpcodeType opCode,
      const U32 cmdSeq,
      F32 val1,
      MathOp op,
      F32 val2
  )
{
  this->tlmWrite_VAL1(val1);
  this->tlmWrite_OP(op);
  this->tlmWrite_VAL2(val2);
  this->log_ACTIVITY_LO_COMMAND_RECV(val1, op, val2);
  this->mathOpOut_out(0, val1, op, val2);
  this->cmdResponse_out(opCode, cmdSeq, Fw::CmdResponse::OK);
}
```

The first two arguments to the handler function provide the command opcode and the command sequence number (a unique identifier generated by the command dispatcher). The remaining arguments are supplied when the command is sent, for example, from the F Prime ground data system (GDS). The implementation code does the following:

    Emit telemetry and events.

    Invoke the mathOpOut port to request that MathReceiver perform the operation.

    Send a command response indicating success. The command response goes out on the special port cmdResponseOut.

In F Prime, every execution of a command handler must end by sending a command response. The proper behavior of other framework components (e.g., command dispatcher, command sequencer) depends upon adherence to this rule.

Check the build using:

```shell
# In: MathSender
fprime-util build
```

Fill in the mathResultIn handler: You should see a stub handler for the mathResultIn port that looks like this:

```cpp
void MathSender ::
  mathResultIn_handler(
      const NATIVE_INT_TYPE portNum,
      F32 result
  )
{
  // TODO
}
```
The handler mathResultIn_handler is called when the MathReceiver component code returns a result by invoking the mathResultIn port. Again the handler overrides the corresponding pure virtual function in the auto-generated base class. Fill in the handler so that it looks like this:

```cpp
void MathSender ::
  mathResultIn_handler(
      const NATIVE_INT_TYPE portNum,
      F32 result
  )
{
    this->tlmWrite_RESULT(result);
    this->log_ACTIVITY_HI_RESULT(result);
}
```

The implementation code emits the result on the RESULT telemetry channel and as a RESULT event report.

Check the build using:

```shell
# In: MathSender
fprime-util build
```

## Summary 
In this section you created the MathComponent and implemented the component's behavior. 